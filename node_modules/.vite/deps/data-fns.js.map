{
  "version": 3,
  "sources": ["../../data-fns/src/lib/times.ts", "../../data-fns/src/lib/mapAt.ts", "../../data-fns/src/lib/getItem.ts", "../../data-fns/src/lib/generateSequence.ts", "../../data-fns/src/lib/cyclic.ts", "../../data-fns/src/lib/palindrome.ts", "../../data-fns/src/lib/modulo.ts", "../../data-fns/src/lib/cellularAutomata.ts", "../../data-fns/src/lib/euclideanSequencer.ts", "../../data-fns/src/lib/euclideanSilences.ts", "../../data-fns/src/lib/patternChunks.ts", "../../data-fns/src/lib/binaryToIndices.ts", "../../data-fns/src/lib/indicesToBinary.ts"],
  "sourcesContent": ["/**\n * Calls a callback function a specified number of times and returns the results in an array.\n * @param iterations The number of times to call the callback function.\n * @param callback The callback function to call.\n * @returns An array containing the results of each callback function call.\n * @example\n * times(5, (i) => i * 2)\n * // Returns [0, 2, 4, 6, 8]\n *\n */\nexport const times = <T>(iterations: number, callback: (index: number) => T): Array<T> => {\n  // Initialize an empty array to store the results\n  const result: Array<T> = []\n\n  // Loop `iterations` number of times, calling the callback function on each iteration\n  for (let i = 0; i < iterations; i++) {\n    // Call the callback function with the current index and push the result to the results array\n    result.push(callback(i))\n  }\n\n  // Return the results array\n  return result\n}\n", "/**\n * Maps an item in an array at a specified index to a new value.\n * @param array The array to map the item in.\n * @param index The index of the item to map.\n * @param mapFn A function that maps the item to a new value.\n * @returns A new array with the mapped item.\n * @example\n * const originalArray = [1, 2, 3, 4, 5]\n * const mappedArray = mapAt(originalArray, 2, (item) => item * 2)\n * // Returns [1, 2, 6, 4, 5]\n */\nexport const mapAt = <T>(array: Array<T>, index: number, mapFn: (item: T) => T): Array<T> => {\n  // Check that the index is within the bounds of the array\n  if (index > array.length || index < 0) {\n    throw new Error('Index out of range')\n  }\n\n  // Get the item at the specified index\n  const item = array[index]\n\n  // Map the item to a new value using the mapFn function\n  const newItem = mapFn(item)\n\n  // If the new value is the same as the original value, return the original array\n  if (newItem === item) {\n    return array\n  }\n\n  // Create a new array with the mapped item\n  const newArray = array.slice()\n  newArray[index] = mapFn(array[index])\n\n  return newArray\n}\n", "/**\n * Gets an item from an array based on a mapped index.\n * @param index The index of the item to get.\n * @param array The array to get the item from.\n * @param indexMapFn A function that maps the index to a new index.\n * @returns The item at the mapped index in the array.\n * @example\n * const array = ['a', 'b', 'c', 'd', 'e']\n * const indexMapFn = (index, length) => (index * 2) % length\n * getItem(2, array, indexMapFn)\n * // Returns 'e'\n */\nexport const getItem = <T>(\n  index: number,\n  array: Array<T>,\n  indexMapFn: (index: number, length: number) => number\n): T => {\n  // Map the index to a new index using the indexMapFn function\n  const mappedIndex = indexMapFn(index, array.length)\n\n  // Return the item at the mapped index in the array\n  return array[mappedIndex]\n}\n", "/**\n * Generates a sequence of values by applying a given function to an initial value for a specified number of iterations.\n * @param iterations The number of iterations to perform.\n * @param initialValue The initial value of the sequence.\n * @param iteratorFn The function to apply to the initial value and each subsequent value.\n * @returns An array containing all the iterations.\n * @example\n * generateSequence(5, 1, (value) => value * 2)\n * // Returns [1, 2, 4, 8, 16]\n */\nexport const generateSequence = <T>(\n  iterations: number,\n  initialValue: T,\n  iteratorFn: (value: T) => T\n): T[] => {\n  if (iterations < 0) {\n    throw new Error('Iterations must be a positive number')\n  }\n\n  if (iterations === 0) {\n    return []\n  }\n\n  const sequence: T[] = [initialValue]\n  let value = initialValue\n\n  for (let i = 1; i < iterations; i++) {\n    value = iteratorFn(value)\n    sequence.push(value)\n  }\n\n  return sequence\n}\n", "/**\n * Maps an index to a cyclic pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the cyclic pattern.\n * @example\n * cyclic(6, 5)\n * // Returns 1\n */\nexport const cyclic = (index: number, length: number): number => {\n  // Calculate the mapped index based on the cyclic pattern\n  const normalizedIndex = index % length\n  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex)\n}\n", "/**\n * Maps an index to a palindrome pattern.\n * @param index The original index.\n * @param length The length of the sequence.\n * @returns The mapped index in the palindrome pattern.\n * @example\n * const length = 5\n * const indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * indexes.map((index) => palindrome(index, length))\n * // Returns [0, 1, 2, 1, 0, 1, 2, 1, 0, 1]\n */\nexport const palindrome = (index: number, length: number): number => {\n  // Save the length of the sequence in a variable\n  const arraySize = length\n\n  // If the sequence has only one element, return 0\n  if (arraySize === 1) {\n    return 0\n  }\n\n  // Calculate the mapped index based on the palindrome pattern\n  const normalizedIndex = index % (2 * arraySize - 2)\n  const id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex\n\n  if (id < arraySize) {\n    return Math.abs(id)\n  } else {\n    return 2 * arraySize - id - 2\n  }\n}\n", "/**\n * Returns the remainder of dividing the dividend by the divisor, with support for negative dividends.\n * @param dividend The dividend to divide.\n * @param divisor The divisor to divide by.\n * @returns The remainder of dividing the dividend by the divisor.\n * @example\n * // Basic usage\n * modulo(5, 3)\n * // Returns 2\n *\n * // Support for negative dividends\n * modulo(-5, -3)\n * // Returns 2\n *\n * // Support for negative divisors\n * modulo(-5, 3)\n * // Returns -2\n *\n * // Support for negative dividends and divisors\n * modulo(5, -3)\n * // Returns -2\n *\n */\nexport const modulo = (dividend: number, divisor: number): number => {\n  // Compute the remainder of dividing the absolute value of the dividend by the absolute value of the divisor.\n  const remainder = Math.abs(dividend) % Math.abs(divisor)\n\n  // Compute the sign of the result based on the sign of the dividend and divisor.\n  const sign = Math.sign(dividend) * Math.sign(divisor)\n\n  // Compute the result by adjusting the remainder based on the sign.\n  const result = remainder * sign\n\n  // Return the result.\n  return result\n}\n", "import { cyclic } from './cyclic'\n\nexport type CellularAutomataRuleset = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n]\n// a common rule that generates an interesting balance between chaos and order\nconst ruleset110: CellularAutomataRuleset = [0, 1, 1, 1, 1, 0, 0, 0]\n\nexport type BoundaryFunction = (index: number, length: number) => number\n\n/**\n * Generates a new sequence using a one-dimensional cellular automaton.\n * @param sequence The initial sequence.\n * @param ruleset The ruleset for the cellular automaton.\n * @param boundaryFn The boundary function to use.\n * @returns The resulting sequence.\n * @example\n *\n * generateSequence(10, sequence, cellularAutomata)\n * // Returns [\n * //  [0, 0, 0, 0, 1, 0, 0, 0],\n * //  [0, 0, 0, 1, 1, 1, 0, 0],\n * //  [0, 0, 1, 1, 0, 0, 1, 0],\n * //  [0, 1, 1, 0, 1, 1, 1, 1],\n * //  [0, 1, 0, 0, 1, 0, 0, 0],\n * //  [1, 1, 1, 1, 1, 1, 0, 0],\n * //  [1, 0, 0, 0, 0, 0, 1, 1],\n * //  [0, 1, 0, 0, 0, 1, 1, 0],\n * //  [1, 1, 1, 0, 1, 1, 0, 1],\n * //  [0, 0, 0, 0, 1, 0, 0, 1],\n * // ]\n *\n * @complexity This function has a time complexity of O(n), where n is the length of the input sequence, and\n * a space complexity of O(n), where n is the length of the input sequence.\n */\nexport const cellularAutomata = (\n  sequence: Array<number>,\n  ruleset: CellularAutomataRuleset = ruleset110,\n  boundaryFn: BoundaryFunction = cyclic\n): Array<number> => {\n  const nextSequence = new Array(sequence.length)\n  const len = sequence.length\n\n  // Apply the ruleset to each cell in the sequence\n  for (let i = 0; i < len; i++) {\n    const left = sequence[boundaryFn(i - 1, len)]\n    const middle = sequence[i]\n    const right = sequence[boundaryFn(i + 1, len)]\n    nextSequence[i] = ruleset[left * 4 + middle * 2 + right]\n  }\n\n  return nextSequence\n}\n", "const numSort = (a: number, b: number) => a - b\n\n/**\n * Generates a Euclidean rhythm sequence.\n * @param steps The number of steps in the sequence.\n * @param notes The number of notes in the sequence.\n * @param rotation The rotation of the sequence (default: 0).\n * @returns An array of indices representing the Euclidean rhythm sequence.\n * @example\n * euclideanSequencer(8, 3, 1)\n * // Returns [1, 3, 6]\n */\nexport const euclideanSequencer = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Check that inputs are positive integers\n  if (steps < 0 || notes < 0) {\n    throw new Error('Inputs must be positive integers')\n  }\n\n  // Initialize an empty sequence array\n  const sequence: Array<number> = []\n\n  // Determine the maximum number of notes in the sequence\n  const maxNotes = notes > steps ? steps : notes\n\n  // Iterate through the number of notes and calculate the index for each note\n  for (let i = 0; i < maxNotes; i++) {\n    const index = Math.floor((i * steps) / maxNotes) // Calculate the index using the Euclidean algorithm\n    sequence.push((index + rotation) % steps) // Add the index to the sequence, with rotation applied\n  }\n\n  // Sort the sequence in ascending order\n  return sequence.sort(numSort)\n}\n", "import { euclideanSequencer } from './euclideanSequencer'\n\n/**\n * Generates a sequence of indices representing the \"silences\" (i.e. rests) in a Euclidean rhythm.\n * @param steps The number of steps in the rhythm.\n * @param notes The number of notes in the rhythm.\n * @param rotation The rotation of the rhythm (default: 0).\n * @returns An array of indices representing the silences in the Euclidean rhythm.\n * @example\n * euclideanSilences(8, 3)\n * // Returns [1, 3, 4, 6, 7]\n */\nexport const euclideanSilences = (steps: number, notes: number, rotation = 0): Array<number> => {\n  // Generate the Euclidean rhythm sequence using the euclideanSequencer function\n  const noteSequence = euclideanSequencer(steps, notes, rotation)\n\n  // Initialize an empty silence sequence array\n  const silenceSequence: Array<number> = []\n\n  // Iterate through each step in the rhythm and add the index to the silence sequence if it is not in the note sequence\n  for (let i = 0; i < steps; i++) {\n    if (!noteSequence.includes(i)) {\n      silenceSequence.push(i)\n    }\n  }\n\n  // Return the silence sequence\n  return silenceSequence\n}\n", "import { cyclic } from './cyclic'\nimport { getItem } from './getItem'\n\n/**\n * Splits an array into chunks based on a pattern.\n * @param array The array to split.\n * @param pattern The pattern to split the array with.\n * @returns An array of arrays representing the splits.\n * @example\n * patternChunks([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 3])\n * // Returns [[1], [2, 3], [4, 5, 6], [7], [8]]\n *\n * @remarks\n * This function splits the input array into chunks based on the specified pattern. The pattern is an array of\n * numbers that determines the size of each chunk. If the pattern is shorter than the input array, it will be\n * repeated cyclically. If the pattern is longer than the input array, the remaining elements will be discarded.\n */\nexport const patternChunks = <T>(array: Array<T>, pattern: Array<number>): Array<Array<T>> => {\n  const result: Array<Array<T>> = []\n  const _array = [...array]\n  let i = 0\n\n  while (_array.length > 0) {\n    result.push(_array.splice(0, getItem(i, pattern, cyclic)))\n    i++\n  }\n\n  return result\n}\n", "/**\n * Converts an array of binary digits to an array of indices where the digit is 1.\n * @param binary An array of binary digits (0 or 1).\n * @returns An array of indices where the digit is 1.\n * @example\n * binaryToIndices([1, 0, 1, 1, 0, 1])\n * // Returns [0, 2, 3, 5]\n *\n * binaryToIndices([1, 1, 1, 1, 1])\n * // Returns [0, 1, 2, 3, 4]\n *\n * binaryToIndices([0, 0, 0, 0, 0])\n * // Returns []\n *\n */\nexport const binaryToIndices = (binary: Array<number>): Array<number> => {\n  // Initialize an empty array to store the indices.\n  const indices: Array<number> = []\n\n  // Loop through the binary array.\n  for (let i = 0; i < binary.length; i++) {\n    // If the digit is 1, add the index to the indices array.\n    if (binary[i] === 1) {\n      indices.push(i)\n    }\n  }\n\n  // Return the array of indices.\n  return indices\n}\n", "/**\n * Converts an array of indices to a binary array where the indices are 1 and the other digits are 0.\n * @param indices An array of indices.\n * @param length The length of the binary array to be returned.\n * @returns A binary array where the indices are 1 and the other digits are 0.\n * @example\n * // Basic usage\n * indicesToBinary([0, 2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Ignoring negative indices\n * indicesToBinary([0, -1, 2, -2, 4], 5)\n * // Returns [1, 0, 1, 0, 1]\n *\n * // Indices outside range are ignored\n * indicesToBinary([0, 2, 4, 6], 5)\n * // Returns [1, 0, 1, 0, 1]\n */\nexport const indicesToBinary = (indices: Array<number>, length: number): Array<number> => {\n  // Initialize a binary array of the given length, filled with 0s.\n  const binary: Array<number> = Array(length).fill(0)\n\n  // Loop through the indices array.\n  for (const index of indices) {\n    // Ignore negative indices.\n    if (index >= 0) {\n      // If the index is within range, set the corresponding digit to 1.\n      if (index < length) {\n        binary[index] = 1\n      }\n    }\n  }\n\n  // Return the binary array.\n  return binary\n}\n"],
  "mappings": "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",
  "names": ["times", "iterations", "callback", "result", "i", "push", "mapAt", "array", "index", "mapFn", "length", "Error", "item", "newItem", "newArray", "slice", "getItem", "indexMapFn", "mappedIndex", "generateSequence", "initialValue", "iteratorFn", "sequence", "value", "cyclic", "normalizedIndex", "Math", "abs", "palindrome", "arraySize", "id", "modulo", "dividend", "divisor", "remainder", "sign", "ruleset110", "cellularAutomata", "ruleset", "boundaryFn", "nextSequence", "Array", "len", "left", "middle", "right", "numSort", "a", "b", "euclideanSequencer", "steps", "notes", "rotation", "maxNotes", "floor", "sort", "euclideanSilences", "noteSequence", "silenceSequence", "includes", "patternChunks", "pattern", "_array", "splice", "binaryToIndices", "binary", "indices", "indicesToBinary", "fill"]
}
