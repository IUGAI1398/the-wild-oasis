import "./chunk-UXIASGQL.js";

// node_modules/data-fns/dist/data-fns.esm.js
var times = function times2(iterations, callback) {
  var result = [];
  for (var i = 0; i < iterations; i++) {
    result.push(callback(i));
  }
  return result;
};
var mapAt = function mapAt2(array, index, mapFn) {
  if (index > array.length || index < 0) {
    throw new Error("Index out of range");
  }
  var item = array[index];
  var newItem = mapFn(item);
  if (newItem === item) {
    return array;
  }
  var newArray = array.slice();
  newArray[index] = mapFn(array[index]);
  return newArray;
};
var getItem = function getItem2(index, array, indexMapFn) {
  var mappedIndex = indexMapFn(index, array.length);
  return array[mappedIndex];
};
var generateSequence = function generateSequence2(iterations, initialValue, iteratorFn) {
  if (iterations < 0) {
    throw new Error("Iterations must be a positive number");
  }
  if (iterations === 0) {
    return [];
  }
  var sequence = [initialValue];
  var value = initialValue;
  for (var i = 1; i < iterations; i++) {
    value = iteratorFn(value);
    sequence.push(value);
  }
  return sequence;
};
var cyclic = function cyclic2(index, length) {
  var normalizedIndex = index % length;
  return Math.abs(normalizedIndex >= 0 ? normalizedIndex : length + normalizedIndex);
};
var palindrome = function palindrome2(index, length) {
  var arraySize = length;
  if (arraySize === 1) {
    return 0;
  }
  var normalizedIndex = index % (2 * arraySize - 2);
  var id = normalizedIndex >= 0 ? normalizedIndex : 2 * arraySize - 2 + normalizedIndex;
  if (id < arraySize) {
    return Math.abs(id);
  } else {
    return 2 * arraySize - id - 2;
  }
};
var modulo = function modulo2(dividend, divisor) {
  var remainder = Math.abs(dividend) % Math.abs(divisor);
  var sign = Math.sign(dividend) * Math.sign(divisor);
  var result = remainder * sign;
  return result;
};
var ruleset110 = [0, 1, 1, 1, 1, 0, 0, 0];
var cellularAutomata = function cellularAutomata2(sequence, ruleset, boundaryFn) {
  if (ruleset === void 0) {
    ruleset = ruleset110;
  }
  if (boundaryFn === void 0) {
    boundaryFn = cyclic;
  }
  var nextSequence = new Array(sequence.length);
  var len = sequence.length;
  for (var i = 0; i < len; i++) {
    var left = sequence[boundaryFn(i - 1, len)];
    var middle = sequence[i];
    var right = sequence[boundaryFn(i + 1, len)];
    nextSequence[i] = ruleset[left * 4 + middle * 2 + right];
  }
  return nextSequence;
};
var numSort = function numSort2(a, b) {
  return a - b;
};
var euclideanSequencer = function euclideanSequencer2(steps, notes, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  if (steps < 0 || notes < 0) {
    throw new Error("Inputs must be positive integers");
  }
  var sequence = [];
  var maxNotes = notes > steps ? steps : notes;
  for (var i = 0; i < maxNotes; i++) {
    var index = Math.floor(i * steps / maxNotes);
    sequence.push((index + rotation) % steps);
  }
  return sequence.sort(numSort);
};
var euclideanSilences = function euclideanSilences2(steps, notes, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var noteSequence = euclideanSequencer(steps, notes, rotation);
  var silenceSequence = [];
  for (var i = 0; i < steps; i++) {
    if (!noteSequence.includes(i)) {
      silenceSequence.push(i);
    }
  }
  return silenceSequence;
};
var patternChunks = function patternChunks2(array, pattern) {
  var result = [];
  var _array = [].concat(array);
  var i = 0;
  while (_array.length > 0) {
    result.push(_array.splice(0, getItem(i, pattern, cyclic)));
    i++;
  }
  return result;
};
var binaryToIndices = function binaryToIndices2(binary) {
  var indices = [];
  for (var i = 0; i < binary.length; i++) {
    if (binary[i] === 1) {
      indices.push(i);
    }
  }
  return indices;
};
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var indicesToBinary = function indicesToBinary2(indices, length) {
  var binary = Array(length).fill(0);
  for (var _iterator = _createForOfIteratorHelperLoose(indices), _step; !(_step = _iterator()).done; ) {
    var index = _step.value;
    if (index >= 0) {
      if (index < length) {
        binary[index] = 1;
      }
    }
  }
  return binary;
};
export {
  binaryToIndices,
  cellularAutomata,
  cyclic,
  euclideanSequencer,
  euclideanSilences,
  generateSequence,
  getItem,
  indicesToBinary,
  mapAt,
  modulo,
  palindrome,
  patternChunks,
  times
};
//# sourceMappingURL=data-fns.js.map
